JAVA堆中存储的对象由自动内存管理系统（也即是常说的垃圾收集器）负责收集，不可以被显示销毁。

# 分代垃圾收集
HotSpot VM使用分代垃圾收集器，此垃圾收集算法基于以下两个观察事实。
- 大多数分配对象的存活时间很短。
- 存活时间久的对象很少引用存活时间短的对象。

上述两个观察事实统称为弱分代假设（Weak Generational Hypothesis），就Java应用而言，这个假设通常成立。HotSpot VM将堆分成2个物理区（也称空间），这就是分代。

## 新生代
大多数新创建的对象被分配在新生代中，与整个Java堆相比，通常新生代的空间比较小而且收集频繁。新生代中大部分对象的存活时间很短，所以通常来说，新生代收集（也称为次要垃圾收集，记作Minor GC）之后存活的对象很少。因为Minor GC关注的是小且有大量垃圾对象的空间，所以通常垃圾收集的效率很高。

## 老年代
新生代中长期存活的对象最后会被提升（Promote [prəˈmoʊt]）或晋升（Tenure [ˈtenjər]）到老年代。通常来说，老年代的空间比新生代大，而空间占用的增长速度比新生代慢。因此，相比Minor GC而言，老年代收集（也称主要垃圾收集或完全垃圾收集，记作Full GC。实际上，HotSpot VM的Full GC会收集整个堆，包括新生代、老年代和永久代）的执行频率比较低，但是一旦发生，执行时间就会很长。

## MethodArea
### 永久代 Permanent Generation（1.7）
这是HotSpot VM内存中的第3块区域。虽然称为代，但实际上不应该把它看作分代层次的一部分（也就是说，用户程序创建的对象最终并不会从老年代移送到永久代）。相反，HotSpot VM只是用它来存储元数据，例如类的数据结构、保留字符串（Interned String）等。

### 元数据区 Metaspace（1.8）
Metaspace，与1.7永久代区别如下：
1. 都是用来存放class
2. 永久代必须指定大小（可能发生内存溢出），元数据区可以设置，也可以不设置，无上限（受限于物理内存）
3. 1.7字符串常量存在永久代，1.8存在于堆中
4. MethodArea是一个逻辑概念，1.7在永久代，1.8在元数据区


分代垃圾收集的一大优点是，每个分代都可以依据其特性使用最适当的垃圾收集算法。新生代通常使用速度快的垃圾收集器。这种垃圾收集器会浪费一点空间，但新生代通常只是Java堆中的一小部分，所以不是什么大问题。另一方面，老年代通常使用空间效率高（有效利用内存空间并最小化内存占用）的垃圾收集器，因为老年代要占用大部分Java堆。这种垃圾收集器不会很快，不过Full GC不会很频繁，所以对性能也不会有很大影响。

分代垃圾收集基于弱分代假设，要想充分发挥分代垃圾收集的威力，应用就必须符合该假设。对于那些不符合该假设的Java应用来说，分代垃圾收集只会增加更多开销，只不过实践中这样的应用很少见。

# HotSpot堆内存结构
![](./../image/JVM/Heap.jpeg)
1. 大多数新创建的对象被分配在新生代的eden区（不是所有，因为大对象可能直接分配到老年代）。Minor GC后eden区几乎总是空的（不为空的情况？）；
2. 在程序运行了一段时间后，新生代的eden区和S0区有对象，S1区为空。Survivor区里存放的对象至少经历了一次Minor GC，它们在提升到老年代之前还有若干次被收集的机会；
3. 当eden区空间不足时，触发一次Minor GC。从eden区和S0区幸存下来的对象将被拷贝到S1区，拷贝完成后，S0区和S1区命名互换，返回情况2。因为收集过程中会复制存活对象，所以这种垃圾收集器称为复制垃圾收集器（Copying Garbage Collector）；  
   3.1. 在Minor GC中存活的对象，如果超过Tenuring Threshold（晋升阈值），会promote（[prəˈmoʊt]，晋升）到老年代。
4. 每次Minor GC后，都会计算一个合理的Tenuring Threshold和各个年代的size，以及适时地调整size；（自适应堆调整仅由Throughput收集器提供，即-XX:UseParallelGC或者-XX:UseParallelOldGC。CMS收集器或Serial收集器不提供）
5. 需要指出的是，在Minor GC过程中，S1区可能不足以容纳eden和S0中的存活对象，多余的对象将被移到老年代，这称为过早晋升（premature（[ˌpriːməˈtʃʊr]） promotion（[prəˈmoʊʃn]））。这会导致老年代中短期存活对象的增长，可能会引发严重的性能问题。再进一步说，在Minor GC过程中，如果老年代满了而无法容纳更多的对象，Minor GC之后通常就会进行Full GC，这将导致遍历整个Java堆，这称为提升失败（Promotion Failure），虽然从JVM的角度是想通过4来避免，但也无法保证；
6. 老年代空间不足时（可能由3.1或5导致），触发Full GC。

# 快速内存分配
对象内存分配器的操作需要和垃圾收集器紧密配合。垃圾收集器必须记录它回收的空间，而分配器在重用堆空间之前需要找到可以满足其分配需求的空闲空间。

垃圾收集器以复制方式回收HotSpot VM新生代的好处在于回收以后Eden总为空，在Eden中运用被称为指针碰撞（Bump the Pointer）的技术就可以有效地分配空间。这种技术追踪最后一个分配对象（常称为top），当有新的分配请求时，分配器只需要检查top和Eden末端之间的空间是否能容纳。如果能容纳，top则跳到新近分配对象的末端。

重要的Java应用大多是多线程的，因此内存分配的操作需要考虑多线程安全。如果只用全局锁，在Eden中的分配操作就会成为瓶颈因而降低性能。HotSpot VM没有采用这种方式，而是以一种称为线程本地分配缓冲区（Thread Local Allocation Buffer, TLAB）的技术，为每个线程设置各自的缓冲区（即Eden的一小块），以此改善多线程分配的吞吐量。因为每个TLAB都只有一个线程从中分配对象，所以可以使用指针碰撞技术快速分配而不需要任何锁。然而，当线程的TLAB填满需要获取新的空间时（不常见），它就需要采用多线程安全的方式了。
