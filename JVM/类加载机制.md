# JAVA虚拟机与程序的生命周期
- 执行了System.exit();
- 程序正常执行结束
- 程序在执行过程中遇到异常或错误而终止
- 由于操作系统出现错误导致JAVA虚拟机进程终止

在如上几种情况下，JAVA虚拟机将结束自己的生命周期。

# 类的生命周期
类的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（UnLoading）7个阶段。其中验证、准备、解析3个阶段统称为连接（Linking）。如图所示：
![](../image/JVM/ClassLifeCycle.png)

加载、验证、准备、初始化和卸载这5个阶段的先后顺序是不变的。而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。
> 1. Java的多态是通过虚函数来实现的
> 2. 虚函数是动态绑定的一种应用
> 3. 动态绑定是通过将类的解析阶段放到初始化阶段之后来实现的
> 
> 从以上3点推导出Java的多态是通过将类的解析阶段放到初始化阶段之后来实现的？

# 加载
查找并加载类的二进制数据，在加载阶段虚拟机需要完成以下三件事：
1. 将类的.class文件的二进制数据读取到内存中。
2. 然后将其放在JVM运行时数据区的方法区内（方法区用于存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据）
3. 最后堆区创建一个java.lang.Class对象，用来封装类在方法区的数据结构

Class对象封装了类在方法区的数据结构，并向用户提供了访问的接口。

## JAVA程序对类的使用方式可以分为两种：
### 主动使用
1. 创建类的实例
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射
5. 初始化一个类的子类
6. JAVA虚拟机启动时被标明为启动类的类

### 被动使用
除了以上6种情况，其它情况均为被动使用。

类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误），如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。

## 加载.class文件的方式
- 从本地系统中直接加载
- 通过网络下载.class文件
- 从zip，jar等归档文件中加载.class文件
- 从专有数据库中提取.class文件
- 将JAVA源文件动态编译为.class文件

## 类加载器
不同的类加载器负责的组件不同，可分为两种类型：
- 自定义的类加载器
- JAVA虚拟机自带的类加载器

JAVA虚拟机自带的类加载器又可以分为三种类型：
- 启动类加载器：Bootstrap ClassLoader，C/C++实现，负责加载存放在JAVA_HOME/jre/lib下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如：rt.jar，所有的java.开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被JAVA程序直接引用的。
- 扩展类加载器：Extension ClassLoader，使用JAVA代码实现，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JAVA_HOME/jre/lib/ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如：javax.开头的类），开发者可以直接使用扩展类加载器。
- 应用程序加载器：Application ClassLoader，使用JAVA代码实现，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

## ClassLoader
![](../image/JVM/ClassLoader1.png)

每个Class对象包含了一个对定义它的ClassLoader的引用。也就是说通过Class对象可以拿到负责加载它的ClassLoader，API如下：
![](../image/JVM/ClassLoader2.png)

返回该类的类加载器。有些实现可能使用null来表示引导类加载器。如果该类由引导类加载器加载，则此方法在这类实现中将返回null。

如果此对象表示一个基本类型或void，则返回null。（JAVA中所有的基本数据类型都是由根加载器加载的，JDK1.5之后void被纳入为基本数据类型）

## 双亲委派模型
双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。

双亲委派机制:
1. 当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。
2. 当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。
3. 如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；
4. 若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。

双亲委派模型意义：
- 系统类防止内存中出现多份同样的字节码
- 保证Java程序安全稳定运行
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
