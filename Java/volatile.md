# 缓存一致性问题
`i = i + 1`

两个线程执行如上代码，假如初始时i的值是0，那么我们期望两个线程执行完后i的值为2。但结果一定是2吗？

存在如下情况：两个线程分别读取i的值到各自的CPU高速缓存中（此时i的值为0），然后线程A对i执行加1操作，并将结果写入到内存中。但在线程B的高速缓存中i的值仍然是0，执行加1操作，i的值为1，然后线程B把i值写入内存。最终i的值为1。 

解决缓存不一致的方法：
1. 通过在总线加LOCK#锁的方式
2. 通过缓存一致性协议

这两种方式都是硬件层面上提供的。

在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件的访问（如内存），从而使得只能有一个CPU使用这个变量的内存。在如上例子中，一个线程在执行 i = i + 1，如果在执行这段代码的过程中，在总线上发出了LOCK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取值，然后进行相应的操作，这样就解决了缓存不一致的问题。

但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。

所以就出现了缓存一致性协议，缓存一致性协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中该变量的缓存行是无效的，那么它就会从内存重新读取。

# 并发编程中的三个概念
在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。

原子性：即一个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。（一个操作，它是不可分割的。一旦执行，要么成功，要么失败，没有中间状态）  
可见性：是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看到修改后的值（可见性只能保证每次读取的是最新的值）。  
有序性：即程序是按照代码书写的先后顺序执行。

一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行顺序同代码中的顺序一致，但是它会保证程序最终的执行结果和代码顺序执行的结果是一致的。

虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？
下面看一个例子：
```java
// 线程A
context = loadContext(); // 语句1
inited = true; // 语句2

// 线程B
while (!inited) {
    sleep();
}
doSomething(context);
```
在上面的代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程A执行过程中先执行语句2，而此时线程B会以为初始化工作已经完成，那么就会跳出while循环，去执行`doSomething(context);`方法，而此时context并没有被初始化，就会导致程序出现非预期的执行结果。

从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到多线程并发执行的正确性。也就是说，要想并发程序正确的执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能导致程序出现非预期的执行结果。

# JAVA内存模型
## 原子性
在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。

分析以下哪些操作是原子性操作：
```java
x = 10; // 语句1
y = x; // 语句2
x++; // 语句3
x = x + 1; // 语句4
```
语句1是直接将数值10赋值给x，也就是说线程执行这个语句会直接将数值10写入到**工作内存**中。

语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及将x的值写入工作内存，这2个操作都是原子性操作，但是合起来就不是原子性操作了。

同样的，`x++`和`x = x + 1`包括3个操作：读取x的值，进行加1操作，写入新的值。

所以上面4个语句只有语句1的操作具备原子性。也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。

从上面可以看出，Java内存模型只保证了读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，自然就不存在原子性问题了。

## 可见性
对于可见性，Java提供了volatile关键字来保证可见性。

另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到**主存**当中，因此可以保证可见性。 

## 有序性
在Java内存模型中，允许编译器和处理器对指令进行重排序，虽然重排序过程不会影响到单线程程序的执行，但是却会影响到多线程并发执行的正确性。

在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻只有一个线程执行同步代码，相当于是让多个线程串行执行同步代码，自然就保证了有序性。

另外，Java内存模型具备一些“先天”的有序性，即不需要通过任何手段就能够得到保证的有序性，通常也称为 happens-before 原则。如果两个操作的执行次序无法从 happens-before 原则推导出来，那么虚拟机就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。

happens-before 原则（先行发生原则）：
- 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
- 锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作
- volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
- 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
- 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作
- 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
- 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过检测Thread.join()方法的结束、Thread.isAlive()的返回值等手段，检测到线程已经终止执行
- 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始

# volatile关键字
volatile关键字的两层语义

一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：
- 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，新值对其他线程来说是立即可见的。
- 禁止进行指令重排序。

```java
// 线程A
boolean stop = false;
while (!stop) {
    doSomething();
}


// 线程B
stop = true;
// valatile保证了原子性吗？
public volatile int inc = 0;

public void increase() {
    inc++;
}

public static void main(String[] args) throws InterruptedException {
    CountDownLatch latch = new CountDownLatch(10);
    final Test test = new Test();
    for (int i = 0; i < 10; i++) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int j = 0; j < 1000; j++) {
                    test.increase();
                }
                latch.countDown();
            }
        }).start();
    }

    latch.await();
    System.out.println(test.inc);
}
```

运行以上代码会发现每次运行结果都不一致，都是一个小于10000的数字。

volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。**可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。**

volatile能保证有序性吗？

在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。volatile关键字禁止指令重排序有两层意思：
1. 在进行指令优化时，不能把volatile变量前面的语句放到其后面执行，也不能把volatile变量后面的语句放到其前面执行。
2. 当程序执行到volatile变量的读操作或者写操作时，在其前面的语句肯定已经全部执行，且结果对后面的操作可见；在其后面的语句肯定还没有执行；

```java
// x、y为非volatile变量
// flag为volatile变量
x = 2; //语句1
y = 0; //语句2
flag = true; //语句3
x = 4; //语句4
y = -1; //语句5
```

如上代码，由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会把语句3放到语句1、语句2前面，也不会把语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。

并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。