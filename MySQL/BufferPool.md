# 缓冲池
缓冲池是内存中一块用于缓存表数据和索引数据的区域。在专用服务器上，通常多达80%的物理内存会分配给缓冲池。

为了提高读取操作的效率，缓冲池被划分为可能包含多行的页（即缓冲池的基本存储单位是页）。同时为了缓存的管理效率，缓冲池被实现为页的链表。

## 预读
预读：磁盘读取并不是按需读取，而是按页读取，一次至少读取一页数据（通常是4K），如果未来要读取的数据就在已读取的页中，就能够省去磁盘I/O，提高效率。

预读为什么有效：当程序访问某个数据时，附近的数据也可能被访问，这就是“局部性原理”，它表明提前加载是有效的，是能够减少磁盘I/O的。

LRU（Least Recently Used）：**最近最久未使用**页面置换算法，当需要向缓冲池添加新页时，新页作为最近访问的页被放置在LRU链表的头部，而最久未使用的页会被淘汰。这里又分两种情况：
1. 页已经在缓冲池中，只要将页移至LRU链表的头部，此时没有页被淘汰。
2. 页不在缓冲池中，将页放置在LRU链表的头部，移除尾部的页。

> 实现LRU算法的一种常见方式是使用双向链表和哈希表结合。双向链表用于保存缓存中的数据项，并按照最近使用的顺序进行排列，最近使用的数据项位于链表的前面。哈希表用于快速查找和访问特定的数据项。

但MySql没有直接使用传统的LRU算法，主要原因是为了解决以下两个问题：
1. 预读失效
2. 缓冲池污染

### 预读失效
放入到缓冲池的页，但之后没有从页中读取数据。

***如何对预读失效进行优化？***
1. 让失效的页停留在缓冲池的时间尽可能的短（尽早被淘汰）；
2. 只有真正被读取的页才放置在LRU的头部。

因此，MySql将LRU链表划分为新生代和老年代，老年代与新生代首尾相连。

当有新的页要加入缓冲池时，新的页只放置在老年代的头部，如果页数据真正被读取（预读成功），才会移至新生代的头部。如果页数据没有被读取（预读失效），将会更早的被淘汰。

### 缓冲池污染
当发生读取大量数据时，缓冲池中的页可能全部被替换出去，导致大量热数据被换出，使MySql性能急剧下降，这种情况叫缓冲池污染。

为了解决缓冲池污染，MySql加入了**老年代停留时间窗口**机制：
1. 第一次访问页后的时间窗口为T；
2. 在老年代的页，即使立刻被读取也不会移至新生代的头部；
3. 只有当数据被访问并且在老年代的停留时间大于T，才会被移至新生代的头部。

因此，缓冲池作为一个列表使用了变种的LRU算进行管理。当需要空间将新页添加到缓冲池时，最近最久未使用的页会被淘汰，新页是添加到列表中间。如下图所示这种中点插入策略将列表视为两个子列表。

![Buffer Pool List](./image/../../image/MySQL/innodb-buffer-pool-list.png)

### 缓冲池配置
- 理想情况下，应该将缓冲池设置为尽可能大的值。缓冲池越大，InnoDB就越像一个内存数据库，从磁盘读取一次数据，然后在后续读取时都是从内存访问数据。
- 在具有足够内存的64位系统上，可以将缓冲池拆分为多个部分，以最大程度减少并发操作对内存结构的争用。
- 将经常访问的数据保存在内存中，避免大量不常访问的数据进入缓冲池。
- 控制如何以及何时执行预读请求。
- 控制何时发生后台刷新以及是否根据工作负载动态调整刷新速率。
- 控制InnoDB如何保留当前缓冲池状态以避免服务器重新启动后的长时间预热。

### 相关参数设置
1. innodb_buffer_pool_size：缓冲池的大小，在内存允许的情况下，建议调大这个参数，越多数据和索引放到内存里，数据库的性能越好。
2. innodb_old_blocks_pct：老年代占真个LRU链表长度的比例，默认是37。
3. innodb_old_blocks_time：老年代停留时间，默认是1000，单位毫秒。

### 总结
1. 缓冲池是一种常见的降低磁盘访问的机制；
2. 缓冲池通常以页为单位缓存数据；
3. 缓冲池的常见管理算法是LRU，Memcache，OS，InnoDB都使用这种算法。
4. MySql对普通的LRU进行了优化：
	* 将缓冲池分为新生代和老年代，以解决预读失效的问题。
	* 设置数据在老年代的停留时间，只有超过这个阈值，数据才会被移至新生代，以解决缓冲池污染的问题。

> 参考：https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool.html