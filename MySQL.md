# 查看sql语句的执行时间
```
set profiling=1;
select * from test;
show profiles;
show profile;
-- 查看query id为2的sql的执行时间
show profile for query 2;
```

# performance_schema

# show processlist;

# Schema与数据类型优化

## 更小的通常更好
应该尽量使用能够正确存储数据的最小数据类型，例如：
- int和tinyint的使用。当字段的取值只有0、1时应该使用tinyint类型。

## 简单就好
简单数据类型的操作通常需要更少的CPU资源，例如：
- 整型比字符串的比较成本更低，因为字符集和校对规则使字符比较比整型比较更复杂。
- 使用MySQL自建类型而不是字符串来存储日期和时间。
- 使用整型存储IP地址（INET_ATON(ip)）

## 尽量避免null
- 负向比较（!=）会引发全表扫描。
- 如果查询中包含可为null的列，对MySQL来说很难优化，因为可为null的列使得索引、索引统计和值比较都更加复杂。

## 数据类型

### 整型
可以使用的几种整型类型：TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT分别使用8，16，24，32，64位存储空间。应尽量使用满足需求的最小数据类型。

### 字符类型
1. char长度固定，即每条数据占用等长字节空间；最大长度是255个字符，适用于身份证号、手机号等定长字符串的存储。
2. varchar可变长度，可以设置最大长度；最大空间是65535个字节，适用于长度差异较大的字符串的存储。
3. text不设置长度，当不知道属性的最大长度时，适合用text。
4. blob采用二进制的存储方式。

### 时间类型
1. datetime，占用8个字节，与时区无关，可保存到毫秒，可保存的时间范围大（1000-01-01 00:00:00 ~ 9999-12-31 23:59:59）
2. timestamp，占用4个字节，依赖数据库设置的时区，精确到秒，时间范围（1970-01-01 00:00:01 ~ 2037-12-31 23:59:59）
3. date，占用3个字节，时间范围（1000-01-01 ~ 9999-12-31）

## 范式和反范式

## 主键

## 字符集

## 存储引擎


# 执行计划
蚂蚁笔记 - MySQL查询优化器


# 索引优化

## 数据结构
1. 二叉树
2. AVL树
3. 红黑树
4. B数
5. B+数

## 索引的用处
- 大大减少查询时需要扫描的数据量
- 避免文件排序和使用临时表
- 随机I/O变成顺序I/O
- 快速查找匹配WHERE子句的行
- 从consideration中消除行，如果可以在多个索引之间进行选择，MySQL通常会使用找到最少行的索引
- 如果表具有多列索引，则优化器可以使用索引的任何最左前缀来查找行
- 当有表连接的时候，从其他表检索行数据
- 查找特定索引列的min或max值
- 如果排序或分组时在可用索引的最左前缀上完成的，则对表进行排序和分组
- 在某些情况下，可以优化查询以检索值而无需查询数据行

## 索引分类
- 主键索引
- 唯一索引
- 普通索引
- 组合索引
- 全文索引

## 技术名词
- 回表
- 最左匹配
- 索引覆盖
- 索引下推

## MySQL中索引使用的数据结构
- B+树
- Hash表

## 索引匹配方式
- 全值匹配
- 最左前缀匹配
- 列前缀匹配（'abc%'）
- 范围匹配
- 精准匹配某一列并范围匹配另一列
- 只访问索引的查询（索引覆盖）

## 哈希索引

## 组合索引

## 聚簇索引与非聚簇索引

## 索引覆盖

## 索引优化
- 当使用索引列进行查询的时候尽量不要使用表达式，把计算放到业务层而不是数据库层
- 尽量使用主键查询，而不是其他索引，因为主键查询不会触发回表查询
- 使用前缀索引（索引字段不宜太长）
- 使用索引扫描来排序
- union all, in, or都能够使用索引，但是推荐使用in
- 范围列可以用到索引
- 强制类型转换会导致全表扫描
- 更新十分频繁，数据区分度不高的字段上不宜建立索引
- 创建索引的列，不允许为null，可能会得到不符合预期的结果
- 当需要进行表连接的时候，需要join的字段数据类型必须一致
- 能使用limit的时候尽量使用limit
- 单表索引个数建议控制在5个以内
- join关联查询时应该用小表驱动大表

## 索引监控
show status like 'Handler_read%';
- Handler_read_first：读取索引第一个条目的次数
- Handler_read_key：通过index获取数据的次数
- Handler_read_last：读取索引最后一个条目的次数
- Handler_read_next：通过索引读取下一条数据的次数
- Handler_read_prev：通过索引读取上一条数据的次数
- Handler_read_rnd：从固定位置读取数据的次数
- Handler_read_rnd_next：从数据节点读取下一条数据的次数


# 查询优化

## 查询慢的原因
- 网络I/O
- 磁盘I/O
- CPU
- 上下文切换
- 系统调用
- 锁等待时间
- 生成统计信息

